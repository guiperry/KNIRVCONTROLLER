import { EventEmitter } from './EventEmitter';

// TypeScript interfaces for HRM WASM module
export interface HRMCognitiveInput {
  sensory_data: number[];
  context: string;
  task_type: string;
}

export interface HRMCognitiveOutput {
  reasoning_result: string;
  confidence: number;
  processing_time: number;
  l_module_activations: number[];
  h_module_activations: number[];
}

export interface HRMModelInfo {
  total_parameters: number;
  l_modules: number;
  h_modules: number;
}

export interface HRMConfig {
  l_module_count: number;
  h_module_count: number;
  enable_adaptation: boolean;
  processing_timeout: number;
}

// WASM module interface (will be generated by wasm-pack)
interface HRMWasmModule {
  HRMCognitive: {
    new(): HRMCognitiveWasm;
  };
}

interface HRMCognitiveWasm {
  initialize_modules(l_count: number, h_count: number): void;
  process_cognitive_input(input_json: string): string;
  get_model_info(): string;
  load_weights(weights_data: Uint8Array): boolean;
  free(): void;
}

export class HRMBridge extends EventEmitter {
  private wasmModule: HRMWasmModule | null = null;
  private hrmInstance: HRMCognitiveWasm | null = null;
  private isInitialized: boolean = false;
  private config: HRMConfig;

  constructor(config: HRMConfig) {
    super();
    this.config = config;
  }

  public async initialize(): Promise<void> {
    try {
      console.log('Initializing HRM WASM bridge...');

      // Load the WASM module
      this.wasmModule = await import('../wasm-pkg/knirv_cortex_wasm');
      
      if (!this.wasmModule) {
        throw new Error('Failed to load HRM WASM module');
      }

      // Create HRM instance
      this.hrmInstance = new this.wasmModule.HRMCognitive();
      
      // Initialize L and H modules
      this.hrmInstance.initialize_modules(
        this.config.l_module_count,
        this.config.h_module_count
      );

      this.isInitialized = true;
      this.emit('initialized');
      
      console.log('HRM WASM bridge initialized successfully');

    } catch (error) {
      console.error('Failed to initialize HRM WASM bridge:', error);
      this.emit('error', error);
      throw error;
    }
  }

  public async loadModelWeights(weightsData: Uint8Array): Promise<boolean> {
    if (!this.isInitialized || !this.hrmInstance) {
      throw new Error('HRM bridge not initialized');
    }

    try {
      console.log('Loading HRM model weights...');
      const success = this.hrmInstance.load_weights(weightsData);
      
      if (success) {
        this.emit('weightsLoaded');
        console.log('HRM model weights loaded successfully');
      } else {
        console.error('Failed to load HRM model weights');
      }

      return success;

    } catch (error) {
      console.error('Error loading model weights:', error);
      this.emit('error', error);
      return false;
    }
  }

  public async processCognitiveInput(input: HRMCognitiveInput): Promise<HRMCognitiveOutput> {
    if (!this.isInitialized || !this.hrmInstance) {
      throw new Error('HRM bridge not initialized');
    }

    try {
      const startTime = performance.now();

      // Convert input to JSON string
      const inputJson = JSON.stringify(input);

      // Process through WASM module
      const outputJson = this.hrmInstance.process_cognitive_input(inputJson);

      // Parse output
      const output: HRMCognitiveOutput = JSON.parse(outputJson);

      const processingTime = performance.now() - startTime;
      
      this.emit('inputProcessed', {
        input,
        output,
        processingTime
      });

      return output;

    } catch (error) {
      console.error('Error processing cognitive input:', error);
      this.emit('error', error);
      throw error;
    }
  }

  public getModelInfo(): HRMModelInfo | null {
    if (!this.isInitialized || !this.hrmInstance) {
      return null;
    }

    try {
      const infoJson = this.hrmInstance.get_model_info();
      return JSON.parse(infoJson) as HRMModelInfo;
    } catch (error) {
      console.error('Error getting model info:', error);
      return null;
    }
  }

  public isReady(): boolean {
    return this.isInitialized && this.hrmInstance !== null;
  }

  public async destroy(): Promise<void> {
    if (this.hrmInstance) {
      this.hrmInstance.free();
      this.hrmInstance = null;
    }

    this.wasmModule = null;
    this.isInitialized = false;
    this.emit('destroyed');
    
    console.log('HRM bridge destroyed');
  }

  // Helper methods for integration with existing cognitive engine
  public async processTextInput(text: string, context?: unknown): Promise<HRMCognitiveOutput> {
    const input: HRMCognitiveInput = {
      sensory_data: this.textToSensoryData(text),
      context: JSON.stringify(context || {}),
      task_type: 'text_processing'
    };

    return this.processCognitiveInput(input);
  }

  public async processVoiceInput(audioData: number[], context?: unknown): Promise<HRMCognitiveOutput> {
    const input: HRMCognitiveInput = {
      sensory_data: audioData,
      context: JSON.stringify(context || {}),
      task_type: 'voice_processing'
    };

    return this.processCognitiveInput(input);
  }

  public async processVisualInput(visualData: number[], context?: unknown): Promise<HRMCognitiveOutput> {
    const input: HRMCognitiveInput = {
      sensory_data: visualData,
      context: JSON.stringify(context || {}),
      task_type: 'visual_processing'
    };

    return this.processCognitiveInput(input);
  }

  private textToSensoryData(text: string): number[] {
    // Convert text to numerical representation for HRM processing
    // This is a simple encoding - in a real implementation, this would use
    // proper tokenization and embedding
    const encoder = new TextEncoder();
    const bytes = encoder.encode(text);
    
    // Normalize to 0-1 range and pad/truncate to fixed size
    const maxLength = 512;
    const normalized = Array.from(bytes).map(b => b / 255.0);
    
    if (normalized.length > maxLength) {
      return normalized.slice(0, maxLength);
    } else {
      return [...normalized, ...new Array(maxLength - normalized.length).fill(0)];
    }
  }

  public getConfig(): HRMConfig {
    return { ...this.config };
  }

  public updateConfig(newConfig: Partial<HRMConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.emit('configUpdated', this.config);
  }

  // Methods required by AdaptiveLearningPipeline interface
  public async process(data: unknown): Promise<unknown> {
    if (typeof data === 'object' && data !== null && 'sensory_data' in data) {
      return this.processCognitiveInput(data as HRMCognitiveInput);
    }
    // Convert other data types to HRM format
    const hrmInput: HRMCognitiveInput = {
      sensory_data: Array.isArray(data) ? data as number[] : [0],
      context: typeof data === 'string' ? data : JSON.stringify(data),
      task_type: 'general'
    };
    return this.processCognitiveInput(hrmInput);
  }

  public isConnected(): boolean {
    return this.isInitialized;
  }
}
