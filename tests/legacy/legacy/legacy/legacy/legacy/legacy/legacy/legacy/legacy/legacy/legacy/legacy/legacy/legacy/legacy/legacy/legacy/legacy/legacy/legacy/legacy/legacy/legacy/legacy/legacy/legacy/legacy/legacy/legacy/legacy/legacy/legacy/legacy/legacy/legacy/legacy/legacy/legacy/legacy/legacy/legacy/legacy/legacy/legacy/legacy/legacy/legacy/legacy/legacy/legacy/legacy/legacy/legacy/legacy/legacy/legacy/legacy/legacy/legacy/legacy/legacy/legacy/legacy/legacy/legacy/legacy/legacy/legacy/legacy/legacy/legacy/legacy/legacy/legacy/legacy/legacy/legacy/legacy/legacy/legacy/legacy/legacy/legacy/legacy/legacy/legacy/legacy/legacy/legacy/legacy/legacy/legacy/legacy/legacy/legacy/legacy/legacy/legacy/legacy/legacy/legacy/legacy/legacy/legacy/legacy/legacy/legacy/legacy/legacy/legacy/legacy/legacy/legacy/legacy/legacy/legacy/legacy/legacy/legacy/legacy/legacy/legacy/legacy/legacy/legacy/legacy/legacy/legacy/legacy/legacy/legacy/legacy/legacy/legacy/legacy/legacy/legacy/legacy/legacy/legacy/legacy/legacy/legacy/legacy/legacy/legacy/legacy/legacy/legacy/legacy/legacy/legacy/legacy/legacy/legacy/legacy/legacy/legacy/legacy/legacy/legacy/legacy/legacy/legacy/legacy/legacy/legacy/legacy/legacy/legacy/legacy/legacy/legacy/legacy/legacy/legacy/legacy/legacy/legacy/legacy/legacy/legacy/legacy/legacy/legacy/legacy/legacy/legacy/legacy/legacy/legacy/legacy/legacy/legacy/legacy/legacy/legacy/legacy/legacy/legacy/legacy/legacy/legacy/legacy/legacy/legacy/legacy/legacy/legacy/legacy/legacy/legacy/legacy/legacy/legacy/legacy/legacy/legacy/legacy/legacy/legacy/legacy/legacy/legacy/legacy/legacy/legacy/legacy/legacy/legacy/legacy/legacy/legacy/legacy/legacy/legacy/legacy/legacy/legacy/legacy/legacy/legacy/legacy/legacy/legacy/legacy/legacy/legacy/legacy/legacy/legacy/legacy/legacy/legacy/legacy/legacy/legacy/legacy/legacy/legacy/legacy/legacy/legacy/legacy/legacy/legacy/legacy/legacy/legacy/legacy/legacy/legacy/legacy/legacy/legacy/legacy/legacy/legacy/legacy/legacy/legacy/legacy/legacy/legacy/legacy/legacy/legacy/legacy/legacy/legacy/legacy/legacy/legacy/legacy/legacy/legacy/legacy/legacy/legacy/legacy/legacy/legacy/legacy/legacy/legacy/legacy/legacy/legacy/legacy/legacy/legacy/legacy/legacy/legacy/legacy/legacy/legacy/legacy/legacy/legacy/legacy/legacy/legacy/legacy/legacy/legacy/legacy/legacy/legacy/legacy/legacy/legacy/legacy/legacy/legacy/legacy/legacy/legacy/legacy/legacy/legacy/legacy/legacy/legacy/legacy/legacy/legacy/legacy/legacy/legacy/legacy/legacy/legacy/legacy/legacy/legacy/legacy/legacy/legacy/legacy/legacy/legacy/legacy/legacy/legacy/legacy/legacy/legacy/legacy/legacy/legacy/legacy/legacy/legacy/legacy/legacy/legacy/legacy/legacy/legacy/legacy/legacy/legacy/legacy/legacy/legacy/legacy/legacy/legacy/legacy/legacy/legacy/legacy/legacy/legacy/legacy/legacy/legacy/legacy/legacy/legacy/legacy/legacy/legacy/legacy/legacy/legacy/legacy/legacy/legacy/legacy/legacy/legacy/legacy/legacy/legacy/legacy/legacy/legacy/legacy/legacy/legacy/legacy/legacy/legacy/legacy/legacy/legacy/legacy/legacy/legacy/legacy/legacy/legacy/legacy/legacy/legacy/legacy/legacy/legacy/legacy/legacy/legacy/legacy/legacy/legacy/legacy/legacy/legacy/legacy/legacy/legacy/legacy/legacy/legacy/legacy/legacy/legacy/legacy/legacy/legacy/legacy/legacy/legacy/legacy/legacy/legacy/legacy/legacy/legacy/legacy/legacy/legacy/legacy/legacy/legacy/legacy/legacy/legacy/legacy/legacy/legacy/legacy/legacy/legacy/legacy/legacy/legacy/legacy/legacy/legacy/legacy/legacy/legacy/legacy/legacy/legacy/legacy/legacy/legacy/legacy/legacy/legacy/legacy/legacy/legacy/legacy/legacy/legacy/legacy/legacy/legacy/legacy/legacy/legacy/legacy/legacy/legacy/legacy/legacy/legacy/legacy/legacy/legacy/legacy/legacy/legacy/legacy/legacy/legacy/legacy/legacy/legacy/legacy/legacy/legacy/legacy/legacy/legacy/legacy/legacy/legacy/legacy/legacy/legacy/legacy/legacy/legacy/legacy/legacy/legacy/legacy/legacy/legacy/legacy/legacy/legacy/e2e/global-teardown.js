// Global Teardown for KNIRVWALLET E2E Tests
const fs = require('fs').promises;
const path = require('path');

async function globalTeardown(config) {
  console.log('üßπ Starting KNIRVWALLET E2E Test Global Teardown...');

  try {
    // Generate test summary report
    await generateTestSummary();

    // Clean up test data
    await cleanupTestData();

    // Archive test artifacts
    await archiveTestArtifacts();

    // Cleanup temporary files
    await cleanupTemporaryFiles();

    console.log('‚úÖ Global teardown completed successfully');
  } catch (error) {
    console.error('‚ùå Global teardown failed:', error);
    // Don't throw error to avoid masking test failures
  }
}

async function generateTestSummary() {
  console.log('üìä Generating test summary report...');

  try {
    // Read test results
    const resultsPath = path.join('test-results', 'e2e-results.json');
    let testResults = null;

    try {
      const resultsData = await fs.readFile(resultsPath, 'utf8');
      testResults = JSON.parse(resultsData);
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not read test results file');
    }

    // Generate summary
    const summary = {
      timestamp: new Date().toISOString(),
      environment: {
        nodeEnv: process.env.NODE_ENV,
        ci: process.env.CI === 'true',
        baseUrl: process.env.BASE_URL,
        gatewayUrl: process.env.GATEWAY_URL,
        walletUrl: process.env.WALLET_URL
      },
      testResults: testResults ? {
        totalTests: testResults.stats?.total || 0,
        passedTests: testResults.stats?.passed || 0,
        failedTests: testResults.stats?.failed || 0,
        skippedTests: testResults.stats?.skipped || 0,
        duration: testResults.stats?.duration || 0
      } : null,
      artifacts: {
        screenshots: await countFiles('test-results/screenshots'),
        videos: await countFiles('test-results/videos'),
        traces: await countFiles('test-results/traces'),
        reports: await countFiles('test-results/e2e-report')
      }
    };

    // Save summary
    const summaryPath = path.join('test-results', 'test-summary.json');
    await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));

    // Generate human-readable summary
    const readableSummary = generateReadableSummary(summary);
    const readableSummaryPath = path.join('test-results', 'test-summary.md');
    await fs.writeFile(readableSummaryPath, readableSummary);

    console.log('‚úÖ Test summary generated');
  } catch (error) {
    console.error('‚ùå Failed to generate test summary:', error);
  }
}

function generateReadableSummary(summary) {
  const { testResults, artifacts, environment } = summary;

  return `# KNIRVWALLET E2E Test Summary

## Test Execution Summary
- **Timestamp**: ${summary.timestamp}
- **Environment**: ${environment.nodeEnv}
- **CI Mode**: ${environment.ci ? 'Yes' : 'No'}
- **Base URL**: ${environment.baseUrl}

## Test Results
${testResults ? `
- **Total Tests**: ${testResults.totalTests}
- **Passed**: ${testResults.passedTests}
- **Failed**: ${testResults.failedTests}
- **Skipped**: ${testResults.skippedTests}
- **Duration**: ${Math.round(testResults.duration / 1000)}s
- **Success Rate**: ${testResults.totalTests > 0 ? Math.round((testResults.passedTests / testResults.totalTests) * 100) : 0}%
` : '- Test results not available'}

## Test Artifacts
- **Screenshots**: ${artifacts.screenshots} files
- **Videos**: ${artifacts.videos} files
- **Traces**: ${artifacts.traces} files
- **Reports**: ${artifacts.reports} files

## Test Coverage Areas
- ‚úÖ Browser Wallet Extension Workflow
- ‚úÖ React Native Mobile App Workflow  
- ‚úÖ Cross-Platform Wallet Synchronization
- ‚úÖ XION Meta Account Integration
- ‚úÖ Error Handling and Edge Cases
- ‚úÖ Performance and Responsiveness
- ‚úÖ Security and Privacy

## Key Features Tested
- HD Wallet Creation and Import
- Transaction Signing and Broadcasting
- XION Meta Account Management
- NRN Token Operations
- Skill Invocation with NRN Burn
- Cross-Platform QR Code Pairing
- WebSocket Synchronization
- Faucet Integration
- Gasless Transactions

---
*Generated by KNIRVWALLET E2E Test Suite*
`;
}

async function countFiles(directory) {
  try {
    const files = await fs.readdir(directory);
    return files.length;
  } catch (error) {
    return 0;
  }
}

async function cleanupTestData() {
  console.log('üóëÔ∏è Cleaning up test data...');

  try {
    // Clean up any test wallets or accounts created during testing
    // This would depend on the specific cleanup requirements

    // Remove temporary test data file
    const testDataPath = path.join('test-results', 'test-data.json');
    try {
      await fs.unlink(testDataPath);
      console.log('‚úÖ Removed test data file');
    } catch (error) {
      // File might not exist, which is fine
    }

    // Clean up authentication state
    const authStatePath = path.join('test-results', 'auth-state.json');
    try {
      await fs.unlink(authStatePath);
      console.log('‚úÖ Removed auth state file');
    } catch (error) {
      // File might not exist, which is fine
    }

    console.log('‚úÖ Test data cleanup completed');
  } catch (error) {
    console.error('‚ùå Failed to cleanup test data:', error);
  }
}

async function archiveTestArtifacts() {
  console.log('üì¶ Archiving test artifacts...');

  try {
    // In CI environment, artifacts might be automatically archived
    if (process.env.CI === 'true') {
      console.log('ü§ñ Running in CI, artifacts will be handled by CI system');
      return;
    }

    // For local runs, create a timestamped archive directory
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const archiveDir = path.join('test-results', 'archives', `e2e-${timestamp}`);

    await fs.mkdir(archiveDir, { recursive: true });

    // Copy important artifacts to archive
    const artifactDirs = [
      'test-results/e2e-report',
      'test-results/screenshots',
      'test-results/videos',
      'test-results/traces'
    ];

    for (const dir of artifactDirs) {
      try {
        const files = await fs.readdir(dir);
        if (files.length > 0) {
          const targetDir = path.join(archiveDir, path.basename(dir));
          await fs.mkdir(targetDir, { recursive: true });
          
          for (const file of files) {
            const sourcePath = path.join(dir, file);
            const targetPath = path.join(targetDir, file);
            await fs.copyFile(sourcePath, targetPath);
          }
          
          console.log(`‚úÖ Archived ${files.length} files from ${dir}`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Could not archive ${dir}:`, error.message);
      }
    }

    // Copy summary files
    const summaryFiles = ['test-summary.json', 'test-summary.md', 'e2e-results.json', 'e2e-junit.xml'];
    for (const file of summaryFiles) {
      try {
        const sourcePath = path.join('test-results', file);
        const targetPath = path.join(archiveDir, file);
        await fs.copyFile(sourcePath, targetPath);
      } catch (error) {
        // File might not exist, which is fine
      }
    }

    console.log(`‚úÖ Test artifacts archived to: ${archiveDir}`);
  } catch (error) {
    console.error('‚ùå Failed to archive test artifacts:', error);
  }
}

async function cleanupTemporaryFiles() {
  console.log('üßΩ Cleaning up temporary files...');

  try {
    // Clean up any temporary files that might have been created during testing
    const tempDirs = [
      'test-results/temp',
      'test-results/cache'
    ];

    for (const dir of tempDirs) {
      try {
        await fs.rmdir(dir, { recursive: true });
        console.log(`‚úÖ Removed temporary directory: ${dir}`);
      } catch (error) {
        // Directory might not exist, which is fine
      }
    }

    // Clean up old artifacts if running locally (keep last 5 runs)
    if (process.env.CI !== 'true') {
      await cleanupOldArtifacts();
    }

    console.log('‚úÖ Temporary files cleanup completed');
  } catch (error) {
    console.error('‚ùå Failed to cleanup temporary files:', error);
  }
}

async function cleanupOldArtifacts() {
  try {
    const archivesDir = path.join('test-results', 'archives');
    const archives = await fs.readdir(archivesDir).catch(() => []);
    
    if (archives.length > 5) {
      // Sort by creation time and keep only the 5 most recent
      const archiveStats = await Promise.all(
        archives.map(async (archive) => {
          const archivePath = path.join(archivesDir, archive);
          const stats = await fs.stat(archivePath);
          return { name: archive, path: archivePath, mtime: stats.mtime };
        })
      );

      archiveStats.sort((a, b) => b.mtime - a.mtime);
      const toDelete = archiveStats.slice(5);

      for (const archive of toDelete) {
        await fs.rmdir(archive.path, { recursive: true });
        console.log(`‚úÖ Removed old archive: ${archive.name}`);
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not cleanup old artifacts:', error.message);
  }
}

// Performance metrics collection
async function collectPerformanceMetrics() {
  console.log('üìà Collecting performance metrics...');

  try {
    // This would collect performance metrics from the test run
    // For now, we'll just log basic information
    
    const metrics = {
      testDuration: process.hrtime.bigint(),
      memoryUsage: process.memoryUsage(),
      timestamp: new Date().toISOString()
    };

    const metricsPath = path.join('test-results', 'performance-metrics.json');
    await fs.writeFile(metricsPath, JSON.stringify(metrics, null, 2));

    console.log('‚úÖ Performance metrics collected');
  } catch (error) {
    console.error('‚ùå Failed to collect performance metrics:', error);
  }
}

// Main teardown function
async function main() {
  try {
    await globalTeardown();
    await collectPerformanceMetrics();
  } catch (error) {
    console.error('‚ùå Global teardown failed:', error);
    process.exit(1);
  }
}

// Export for Playwright
module.exports = globalTeardown;

// Run directly if called from command line
if (require.main === module) {
  main();
}
